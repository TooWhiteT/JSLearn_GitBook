# 操作符

### 一元操作符

```javascript
++a 
a++
i--
--i
```

### 位操作符

ECMAScript 中的所有数值都以 64 位存储，但位操作并不直接应用到 64 位表示，而是先把值转换为 32 位整数，再进行位操作，之后再把结果转换为 64 位。

对开发者而言，就好像只有 32 位整数一样，因 为 64 位整数存储格式是不可见的。既然知道了这些，就只需要考虑 32 位整数即可。 有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正， 1 表示负。这 一位称为**符号位（ sign bit）**，它的值决定了数值其余部分的格式。正值以真正的二进制格式存储，即 31 位中的每一位都代表 2 的幂。第一位（称为第 0 位）表示 20，第二位表示 21，依此类推。如果一个位是空的，则以 0 填充， 相当于忽略不计。比如， 数值 18 的二进制格式为 00000000000000000000000000010010， 或更精简的 10010。后者是用到的 5 个有效位，决定了实际的值.

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>



负值以一种称为**二补数（或补码）**的二进制编码存储。一个数值的二补数通过如下 3 个步骤计算 得到：&#x20;

1. 确定绝对值的二进制表示（如，对于-18，先确定 18 的二进制表示）；
2. 找到数值的一补数（或反码），换句话说，就是每个 0 都变成 1，每个 1 都变成 0；&#x20;
3. 给结果加 1。

```
基于上述步骤确定18 的二进制表示，首先从 18 的二进制表示开始：
0000 0000 0000 0000 0000 0000 0001 0010
然后，计算一补数，即反转每一位的二进制值：
1111 1111 1111 1111 1111 1111 1110 1101
最后，给一补数加 1：
1111 1111 1111 1111 1111 1111 1110 1101
1
----------------------------------------------
1111 1111 1111 1111 1111 1111 1110 1110
那么，18 的二进制表示就是 11111111111111111111111111101110。要注意的是，在处理有符号整数
时，我们无法访问第 31 位。
```

```javascript
// 在把负值输出为一个二进制字符串时，我们会得到一个前面加了减号的绝对值，如下所示：
let num = -18;
console.log(num.toString(2)); // "-10010"
// 在将18 转换为二进制字符串时，结果得到10010。
// 转换过程会求得二补数，然后再以更符合逻辑的形式表示出来。
```

默认情况下， ECMAScript 中的所有整数都表示为有符号数。不过，确实存在无符 号整数。对无符号整数来说，第 32 位不表示符号，因为只有正值。无符号整数比有符号 整数的范围更大，因为符号位被用来表示数值了。在对 ECMAScript 中的数值应用位操作符时，后台会发生转换： 64 位数值会转换为 32 位数值，然 后执行位操作，最后再把结果从 32 位转换为 64 位存储起来。整个过程就像处理 32 位数值一样，这让二进制操作变得与其他语言中类似。但这个转换也导致了一个奇特的副作用， **即特殊值 NaN 和 Infinity 在位操作中都会被当成 0 处理。** **如果将位操作符应用到非数值，那么首先会使用 Number()函数将该值转换为数值（这个过程是自动的），然后再应用位操作。最终结果是数值。**

#### 按位非(\~)

```javascript
let num1 = 25; // 二进制 00000000000000000000000000011001
let num2 = ~num1; // 二进制 11111111111111111111111111100110
console.log(num2); // -26

// 同下面计算 但是上面基于底层位操作会比下面计算快
let num1 = 25;
let num2 = -num1 - 1;
console.log(num2); // -26
```

#### 按位与(&)

按位与操作在两个位都是 1 时返回 1，在任何一位是 0 时返回 0

```javascript
let result = 25 & 3;
console.log(result); // 1
// 如何得出？ 下面解析过程
`
25 = 0000 0000 0000 0000 0000 0000 0001 1001
3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001
`
```

#### 按位或(|)

按位或操作在至少一位是 1 时返回 1，两位都是 0 时返回 0

```javascript
let result = 25 | 3;
console.log(result); // 27
// 如何得出？ 解析过程 
`
25 = 0000 0000 0000 0000 0000 0000 0001 1001
3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
OR = 0000 0000 0000 0000 0000 0000 0001 1011
`
```

#### 按位异或(^)

按位异或操作只在一位上是 1 的时候返回 1（两位都是 1 或 0，则返回 0）

```javascript
let result = 25 ^ 3;
console.log(result); // 26
// 如何得出？
`
25 = 0000 0000 0000 0000 0000 0000 0001 1001
3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
XOR = 0000 0000 0000 0000 0000 0000 0001 1010
`
```

#### 左移(<<)

按照指定的位数将数值的所有位向左移动

```javascript
let oldValue = 2; // 等于二进制 10
let newValue = oldValue << 5; // 等于二进制 1000000，即十进制 64
```

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

注意，左移会保留它所操作数值的符号。比如，如果-2 左移 5 位，将得到-64，而不是64。

#### 有符号右移(>>)

将数值的所有 32 位都向右移，同时保留符号（正或负）。 有符号右移实际上是左移的逆运算。

```javascript
let oldValue = 64; // 等于二进制 1000000
let newValue = oldValue >> 5; // 等于二进制 10，即十进制 2
```

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

同样，移位后就会出现空位。不过，右移后空位会出现在左侧，且在符号位之后。 ECMAScript 会用符号位的值来填充这些空位，以得到完整的数值

#### 无符号右移(>>>)

将数值的所有 32 位都向右移。对于正数，无符号右移与 有符号右移结果相同。

```javascript
let oldValue = 64; // 等于二进制 1000000
let newValue = oldValue >>> 5; // 等于二进制 10，即十进制 2
```

对于负数，有时候差异会非常大。与有符号右移不同，无符号右移会给空位补 0，而不管符号位是 什么。对正数来说，这跟有符号右移效果相同。

```javascript
let oldValue = -64; // 等于二进制 11111111111111111111111111000000
let newValue = oldValue >>> 5; // 等于十进制 134217726
// 在对64 无符号右移 5 位后，结果是 134217726。 
// 这是因为64 的二进制表示是 11111111111111111111111111000000，
// 无符号右移却将它当成正值，也就是 4294967232。
// 把这个值右移 5 位后，结果是00000111111111111111111111111110，即 134217726。
```

对负数来说，结果就差太多了。无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理。因为负数是其绝对值的二补数，所以右移之后结果变 得非常之大

### 布尔操作符

